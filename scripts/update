#!/usr/bin/env python3
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/collecting_society_docker
"""
Usage: ./scripts/update [--reset] [--diff] [--help]

  This script updates the project:
    - Creation of files and folders
    - Copy of FILE.example files to FILE
    - Checkout/Pull of the source repositories (including this one)
    - Checkout/Pull of the reference repositories

Options:
  --reset: overrides the configuration files with .example
  --diff: just outputs the diff of .example files, performs no other updates
"""

import os
import sys
import shutil
import traceback
import subprocess
import pprint
from subprocess import STDOUT as stdout
from pathlib import Path
import difflib
import re
import yaml
from collections.abc import Mapping
from collections import OrderedDict
from copy import deepcopy

# regex
envre = re.compile(r'''^([^\s=]+)=(?:[\s"']*)(.+?)(?:[\s"']*)$''')
envsubre = re.compile(r'\$\{([A-Z-_]*)\}')

# lists
_contexts = []       # list of contexts
_messages = []       # list of messages added
_tasks = []          # list of tasks performed
_actions = []        # list of valid action names, autofilled
_commands = []       # list of valid command names, autofilled

# params
_command = None      # the initially invoked command
_commit_msg = ""     # commit message

# flags
_reset = False       # reset example files
_verbose = False     # verbose output
_debug = False       # debug output
_ci = False          # ci mode
_colored = True      # colored output
_self_updated = False
_script_updated = False
_dockerfile_updated = False
_examplefiles_updated = False


# --- tools -------------------------------------------------------------------

def get_root_dir():
    """Returns the root directory of the project."""
    root = os.path.realpath(
        os.path.join(os.path.abspath(__file__), "..", ".."))
    assert os.path.exists(os.path.join(root, '.git'))
    return root


def get_repo_name(path="."):
    """Returns the repository name of the project."""
    return os.path.basename(os.path.abspath(path))


def get_repo_branch(path="."):
    return subprocess.check_output(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
        stderr=subprocess.STDOUT).rstrip().decode('utf-8')


def replace_env_vars(dictionary, env):
    """Substitues placeholders in dictionary with environment variables."""
    for key, val in dictionary.items():
        if isinstance(val, Mapping):
            replace_env_vars(val, env)
        elif isinstance(val, list):
            for i, item in enumerate(val):
                if isinstance(item, str):
                    for (match) in envsubre.findall(item):
                        dictionary[key][i] = dictionary[key][i].replace(
                            '${%s}' % match, env[match])
                    continue
                replace_env_vars(item, env)
        elif isinstance(val, str):
            for (match) in envsubre.findall(val):
                dictionary[key] = dictionary[key].replace(
                    '${%s}' % match, env[match])
    return dictionary


def get_dot_env(path="."):
    """Reads the shared environment file and parses it into a dictionary."""
    path = os.path.join(path, ".env")
    if not os.path.isfile(path):
        path += '.example'
    assert os.path.isfile(path)
    env = {}
    with open(path) as _file:
        for line in _file:
            match = envre.match(line)
            if match is not None:
                env[match.group(1)] = match.group(2)
    return replace_env_vars(env, env)


def get_project_yaml(path=".", env={}):
    """Reads the project yaml file and parses it into a dictionary."""
    with open(os.path.join(path, "project.yml"), 'r') as _file:
        # load yaml file
        project = yaml.safe_load(_file)
        replace_env_vars(project, env)
        # inherit configurations
        project['staging'] = merge_dicts(
            deepcopy(project['production']), project['staging'])
        project['testing'] = merge_dicts(
            deepcopy(project['staging']), project['testing'])
        project['development'] = merge_dicts(
            deepcopy(project['testing']), project['development'])
        # environment validation
        for _e, environment in project.items():
            if not environment:
                continue
            # action groups
            groups = environment.get('actions', {})
            for _g, group in groups.items():
                if not isinstance(group, list):
                    continue
                # valid actions in action groups
                for action in group:
                    assert action in _actions, (
                        "action `%s` in group `%s` not found.\n\n"
                        "yaml: %s/actions/%s\n"
                        "group: %s" % (action, _g, _e, action, group)
                    )
                continue
            # tasks
            tasks = environment.get('tasks', {})
            for _c, tasks in environment.get('tasks', {}).items():
                for task in tasks or []:
                    # ensure task name
                    assert task.get('name'), (
                        "task has no name.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (_e, _c, task)
                    )
                    # ensure task action
                    assert task.get('actions'), (
                        "task has no action.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (_e, _c, task)
                    )
                    # ensure task actions are a list
                    actions = task.get('actions', [])
                    if isinstance(actions, str):
                        task['actions'] = [actions]
                    # substitue task groups
                    actions = []
                    for action in task['actions']:
                        islist = isinstance(groups.get(action), list)
                        if action in groups and islist:
                            actions += groups[action]
                            continue
                        actions.append(action)
                    task['actions'] = actions
                    # ensure task actions are valid
                    for action in task.get('actions', []):
                        assert action in _actions, (
                            "action `%s` of task with name `%s` not found.\n\n"
                            "yaml: %s/tasks/%s\n"
                            "task: %s" % (action, task['name'], _e, _c, task)
                        )
                    # batch tasks
                    if not task.get('batch'):
                        continue
                    for batch_task in task['batch']:
                        # ensure task name
                        assert batch_task.get('name'), (
                            "task has no name.\n\n"
                            "yaml: %s/tasks/%s\n"
                            "task: %s" % (_e, _c, batch_task)
                        )
                        # ensure task actions are valid
                        for action in batch_task.get('actions', []):
                            assert action in _actions, (
                                "action `%s` of batch task with name `%s` "
                                "in task with name %s not found.\n\n"
                                "yaml: %s/tasks/%s\n"
                                "task: %s\n"
                                "batch_task: %s" % (
                                    action, batch_task['name'], task['name'],
                                    _e, _c, task, batch_task)
                            )
    return project


def merge_dicts(orig_dict, new_dict):
    """
    Recursively merges dict-like objects.

    Note:
        If a value in new_dict is `{}`, the key is removed in orig_dict.
        Lists of dicts
        - are merged with key 'name' as identifier.
        - can be inserted with the key 'before'/'after' and value name.

    Args:
        orig_dict (dict): Original dictionary to be merged with.
        new_dict (dict): New dictionary to be merged.

    Returns:
        dict: Merged dict.

    Examples:
        >>> orig_dict = {
        ...     'A': {
        ...         'A1': 'A1',
        ...         'A2': 'A2'
        ...     },
        ...     'B': 'B'
        ...     'C': [
        ...         {'name': 'one', 'item': 'old'},
        ...         {'name': 'three'},
        ...     ]
        ... }
        >>> new_dict = {
        ...     'A': {
        ...         'A2': 'XX'
        ...     },
        ...     'B': {},
        ...     'C': [
        ...         {'name': 'one', 'item': 'new'},
        ...         {'name': 'two', 'after': 'one'},
        ...     'D': 'D'
        ... }
        >>> print(cls.merge_dicts(orig_dict, new_dict))
        {
            'A': {
                'A1': 'A1',
                'A2': 'XX'
            },
            'C': [
                {'name': 'one', 'item': 'new'},
                {'name': 'two'},
                {'name': 'three'},
            ],
            'D': 'D',
        }
    """
    if not new_dict:
        return isinstance(new_dict, Mapping) and new_dict or orig_dict
    for key, val in new_dict.items():
        # delete key if val == {}
        if isinstance(val, Mapping) and not val:
            orig_dict.pop(key, None)
        # update with OrderedDict
        if isinstance(val, OrderedDict):
            r = merge_dicts(OrderedDict(orig_dict.get(key, {})), val)
            orig_dict[key] = r
        # update with Mapping
        elif isinstance(val, Mapping):
            r = merge_dicts(orig_dict.get(key, {}), val)
            orig_dict[key] = r
        # update with Lists of items having all the key 'name'
        elif isinstance(val, list) and \
                sum(['name' in v for v in val]) == len(val):
            for new_item in val:
                new = True
                for i, orig_item in enumerate(orig_dict[key]):
                    if new_item['name'] == orig_item['name']:
                        new = False
                        orig_dict[key][i] = merge_dicts(orig_item, new_item)
                if new:
                    insert = ''
                    if 'after' in new_item:
                        insert = 'after'
                    if 'before' in new_item:
                        insert = 'before'
                    if insert:
                        for i, orig_item in enumerate(orig_dict[key]):
                            if new_item[insert] == orig_item['name']:
                                break
                        if insert == 'after':
                            i += 1
                        new_item.pop('after', None)
                        new_item.pop('before', None)
                        orig_dict[key].insert(i, new_item)
                    else:
                        orig_dict[key].append(new_item)
        # update with other objects
        elif isinstance(orig_dict, Mapping):
            orig_dict[key] = new_dict[key]
        else:
            orig_dict = {key: new_dict[key]}
    return orig_dict


# --- templates ---------------------------------------------------------------

def color(text, status):
    """Colored output wrapper for stdout text."""
    if not _colored:
        return text
    text = str(text)
    if isinstance(status, str):
        status = [status]
    # start
    for s in status:
        s = s.lower()
        if s.startswith("\033"):
            text = s + text
        if s in colors:
            text = color(text, colors[s])
    # stop
    if text.startswith("\033") and not text.endswith("[0m"):
        text += colors['clear']
    return text


def message(msg, offset=1, pad=10, data=True, add=True, output=True):
    """Prints a message."""
    # default
    default = {'level': "debug"}
    if _tasks:
        default['action'] = _tasks[-1]['action'].replace("_", " ")
        default['title'] = _tasks[-1]['name']
    msg = {**default, **msg}
    # color
    _color = msg.get("level", "dim")
    # level
    text = "  " * offset
    level = (msg['level'] + " | ").rjust(pad)
    text += color(level, _color + "_level")
    # title
    if 'title' in msg:
        title = msg['title']
        if title == ".":
            title = repo
        text += color(title, _color + "_title") + " "
    # action
    if 'action' in msg:
        action = msg['action'] + " ... "
        if msg['level'] == "error":
            action = msg['action']
        if 'description' in msg:
            action = msg['action'] + " » "
        text += color(action, _color + "_action")
    # description
    if 'description' in msg:
        if msg['level'] == 'error':
            _color = 'info'
        text += color(msg["description"], [_color + "_description", 'italic'])
    # data
    if data and 'data' in msg and msg['data']:
        raw = msg['data']
        if isinstance(raw, (bytes, bytearray)):
            raw = raw.strip().decode('utf-8')
        lines = raw
        if isinstance(raw, str):
            lines = raw.rstrip().split("\n")
        else:
            lines = pprint.pformat(raw).split("\n")
        data = ""
        for line in lines:
            data += "\n" + "  " * offset + " ".ljust(pad) + line
        data += "\n"
        text += color(data, _color + "_data")
    text += "\n"
    # process
    if add:
        _messages.append(msg)
    if output and msg['level'] in levels['output']:
        print(text, end="")
    return text


def line(length=89, _color="title", end="\n", output=True):
    """Prints a division line."""
    text = color("-" * length, _color)
    # process
    if output:
        print(text, end=end)
    return text


def header(output=True):
    """Prints the project configuration header."""
    context = get_context()
    # data
    data = {
        "project": env.get('PROJECT'),
        "environment": environment,
        "branch": branch,
        "root": root,
    }
    if git_name and git_email:
        data['gituser'] = "%s <%s>" % (git_name, git_email)
    else:
        global_username = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        global_useremail = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        data['gituser'] = "%s <%s>" % (global_username, global_useremail)
        message({'level': "info",
                 'description': "GIT_USER_NAME/EMAIL in .env not set",
                 'data': "NOTE: commits will use: %s" % data['user']})
    # text
    pad = 0
    for key in data:
        if len(key) > pad:
            pad = len(key)
    pad += 1
    text = "\n"
    for key, value in data.items():
        value_color = 'dim'
        if key in ['environment', 'branch'] and value not in environments:
            value_color = 'warning'
        text += (
            color("  " + key.capitalize().ljust(pad), 'title') +
            color(value + "\n", value_color)
        )
    separator = line(output=False)
    text = "\n" + separator + "\n" + text + "\n" + separator + "\n\n"
    # extended mode
    extended = context['commands'].get('extended')
    if not extended:
        text = "\n"
    # process
    if output:
        print(text, end="")
    return text


def title(string, _color="subtitle", output=True):
    """Prints a formatted title."""
    text = "\n" + color("> ", 'title') + color(string, _color) + "\n\n"
    # process
    if output:
        print(text, end="")
    return text


def footer(string="Success.", _color="success", output=True, summary=True):
    """Prints the result of the command and a summary of important messages."""
    context = get_context()
    # determine what to output
    had_output = 0
    has_summary = False
    for msg in _messages:
        if msg['level'] in levels['output']:
            had_output += 1
            if msg.get('data'):
                had_output += str(msg['data']).count("\n") + 2
        if msg['level'] in levels['summary']:
            has_summary = True
    if not had_output:
        print(color("   All fine.", 'dim'))
    if had_output < 50:
        summary = False
    # output
    text = ""
    # separator
    text += "\n" + line(output=False) + "\n"
    # summary
    if summary and has_summary:
        text += title("Summary", _color='title', output=False) + "\n"
        for level in levels['summary']:
            for msg in [m for m in _messages if m['level'] == level]:
                text += message(msg, data=False, add=False, output=False)
    # title
    text += title(string, _color=_color, output=False)
    # extended mode
    extended = context['commands'].get('extended')
    if not extended:
        text = ""
    # process
    if output:
        print(text, end="")
    return text


def debug(obj=None, title=""):
    """Prints objects for debugging."""
    if not _debug:
        return
    pad = 12
    # title
    if title:
        print(" " * pad + color(title, ['output', 'bold']))
    # object
    if not isinstance(obj, str):
        obj = pprint.pformat(obj)
    for line in obj.split("\n"):
        print(" " * pad + color(line, 'output'))
    print()


def error(msg):
    """Prints an error."""
    _msg = {
        'level': "error",
    }
    if _tasks:
        _msg['title'] = "%s: `%s`" % (
            _tasks[-1]['action'].replace("_", " "), _tasks[-1]['name'])
    message({**_msg, **msg})
    footer("Aborted.", _color="info", summary=False)
    sys.exit(-1)


# --- execution ---------------------------------------------------------------

def execute(cmd, cwd=False, abort=True, msg={}, log=True,
            stop_batch_group=False, stop_action_group=False):
    """Executes a command via subprocess check_output."""
    # print hint for the operation
    context = get_context()
    task = None
    action = "command"
    title = " ".join(cmd)
    if _tasks:
        task = _tasks[-1]
        action = task['action'].replace("_", " ") or "command"
        title = task['name'] or " ".join(cmd)
    if log:
        message({'action': action, 'title': title}, add=False)
    output = ""
    error_msg = {}

    # execute command
    try:
        output = subprocess.check_output(
            cmd, cwd=cwd or root, stderr=stdout
        ).rstrip().decode('utf-8')
        if _debug:
            debug(output, "$ " + " ".join(cmd))
    except subprocess.CalledProcessError as err:
        error_msg = {
            'title': "$ " + cmd[0],
            'action': len(cmd) > 1 and " ".join(cmd[1:]) or "",
            'data': err.output,
        }
        if abort:
            error(error_msg)

    # add output to task
    if context['task']:
        context['task']['output'][" ".join(cmd)] = output
        context['task']['result'][context['action']] = output

    # stop batch groups
    if task and stop_batch_group:
        stopped = output
        if callable(stop_batch_group):
            stopped = stop_batch_group(output)
        context['batch_group']['stopped'] = stopped

    # stop action groups
    if task and stop_action_group:
        stopped = output
        if callable(stop_action_group):
            stopped = stop_action_group(output)
        context['action_group']['stopped'] = stopped

    # return if logging is disabled for this command
    if not log:
        return output

    # create message
    _msg = {
        'level': output and "warning" or "info",
        'action': action,
        'title': title,
        'description': output and "not ok" or "ok",
        'data': output and "$ " + " ".join(cmd) + "\n" + output,
    }
    msg = {**_msg, **msg, **error_msg}

    # execute callback functions for messages dependent on the output
    for key, value in msg.items():
        if callable(value):
            msg[key] = value(output)

    # remove line, add and print message
    if 'debug' in levels['output']:
        sys.stdout.write("\033[F")
    message(msg)

    return output


# --- actions -----------------------------------------------------------------

def action(func):
    """Action decorator, registers available functions, skips stopped tasks."""
    current_action = func.__name__
    # add action name to list of actions
    _actions.append(current_action)

    def wrapper(task, context={}, *args, **kwargs):
        # get last context, if empty
        if not context:
            context = get_context()
        # stop to process stopped action groups or batch groups
        if context['batch_group'].get("stopped"):
            return
        if context['action_group'].get("stopped"):
            return
        # set the context
        actions = project[environment]['actions']
        if current_action not in actions:
            actions[current_action] = {}
        context['actions'] = actions[current_action]
        context['action'] = current_action
        if 'output' not in context['task']:
            context['task']['output'] = {}
        if 'result' not in context['task']:
            context['task']['result'] = {}
        # apply the action
        try:
            func(task, context, *args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
    return wrapper


@action
def path_link(task, context={}):
    """Symlinks a file or folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # source path does not exist
    if not os.path.exists(source):
        error({'description': "source path not found",
               'data': "source: %s" % task['source']})

    # new symlink, file does not exist
    source_rel = os.path.relpath(source, os.path.dirname(target))
    if not os.path.exists(target):
        os.symlink(source_rel, target)
        message({'level': "info", 'description': "symlink created"})
        return

    # file exists, but is no symlink
    if not os.path.islink(target):
        error({'description': "target exists and is not a link"})

    # symlink exists and points already to source
    old_source = os.readlink(target)
    if source_rel == old_source:
        message({'description': "symlink exists"})
        return

    # symlink exists, but is changed
    os.unlink(target)
    os.symlink(source_rel, target)
    message({'level': "warning", 'description': "symlink overwritten",
             'data': "\n".join(["old source: `%s`" % old_source,
                                "new source: `%s`" % source_rel])})


@action
def file_create(task, context={}):
    """Creates a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)
    target_folder = os.path.dirname(target)

    # folder of file does not exist
    if not os.path.isdir(target_folder):
        error({'description': "folder does not exist", 'data': target_folder})

    # file already exists
    if os.path.exists(target):
        message({'description': "file exists"})
        return

    # new file created
    Path(target).touch()
    message({'level': "info", 'description': "file created"})


@action
def file_copy(task, context={}):
    """Copies a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source file to copy not found
    if not os.path.exists(source):
        error({'description': "source file not found"})

    # file already exists
    target_exists = os.path.exists(target)
    if target_exists and not _reset:
        message({'description': "file_exists"})
        return

    # file overwritten due to reset switch
    if target_exists and _reset:
        shutil.copyfile(source, target)
        message({'level': "warning", 'description': "file overwritten"})
        return

    # new file copied
    shutil.copyfile(source, target)
    message({'level': "info", 'description': "file copied"})


@action
def file_diff(task, context={}):
    """Diffs example files, prints output and returns different filenames."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source or target not found
    if not os.path.exists(source):
        error({'description': "source path not found"})
    if not os.path.exists(target):
        error({'description': "target path not found"})

    # create diff
    with open(source, 'r') as source_file, open(target, 'r') as target_file:

        # get diff
        source_content = source_file.readlines()
        target_content = target_file.readlines()
        diff = difflib.unified_diff(
            source_content, target_content,
            fromfile=os.path.basename(source), tofile=task["name"])
        try:
            line = next(diff)
        except StopIteration:
            message({'description': 'file is identical'})
            return
        lines = [line] + [d for d in diff]

        # filter diff
        ignored = False
        ignore = task.get('ignore')
        if ignore:
            if isinstance(ignore, list):
                ignore = context['actions'].get('ignore', []) + task['ignore']
                ignore = re.compile(r'(%s)' % "|".join(ignore))
                task['ignore'] = ignore
            filtered = []
            for line in lines[2:]:
                if not line[0] in ["+", "-"]:
                    continue
                match = ignore.match(line[1:])
                if match is not None:
                    ignored = True
                    continue
                filtered.append(line)
            lines = lines[0:3] + filtered

            # files contains only ignored differences
            if not filtered:
                message({'level': 'info',
                         'description': 'diff contains only ignored lines'})
                return

        # color diff
        data = colors['clear']
        if ignored:
            data += color("--8<-- (ignored lines stripped) --8<--", "dim")
            data += colors['clear'] + "\n"
        for line in lines:
            if line.startswith('-'):
                data += colors['remove']
            if line.startswith('+'):
                data += colors['add']
            if line.startswith('@'):
                data += colors['hunk']
            data += line
        data = data.rstrip() + colors['clear']

        # example files were updated
        if _examplefiles_updated:
            message({'level': "error",
                     'description': "differences found (examplefiles changed)",
                     'data': data})
            return

        # differences found
        message({'level': "warning", 'description': "differences found",
                 'data': data})


@action
def folder_create(task, context={}):
    """Creates a folder."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)

    # folder already exists
    if os.path.exists(target):
        message({'description': "folder exists"})
        return

    # new folder created
    os.makedirs(target)
    message({'level': "info", 'description': "folder created"})


@action
def folder_copy(task, context={}):
    """Copies a folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # folder already exists
    if os.path.exists(target) and not _reset:
        message({'description': "folder exists"})
        return

    # folder overwritten due to reset switch
    shutil.copytree(source, target)
    if _reset:
        shutil.copytree(source, target)
        message({'level': "info", 'description': "folder copied"})
        return

    # new folder copied
    shutil.copytree(source, target)
    message({'level': "warning", 'description': "folder overwritten"})


@action
def git_clone(task, context={}):
    """Clones a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # create containing path for repo
    if context['actions']['create_folder']:
        folder_create({'name': os.path.dirname(target)})

    # choose ssh or https
    if git_protocol == 'https' and "@" in source:
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # repo already exists
    if os.path.exists(os.path.join(target, '.git')):
        message({'description': "repo exists"})
        return

    # new repo cloned
    execute(('git', 'clone', '--quiet', source, target))


@action
def git_origin(task, context={}):
    """Sets the origin of a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # choose ssh or https
    if git_protocol == 'https' and "@" in source:
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # origin already set
    old_source = execute(
        ('git', 'remote', 'get-url', 'origin'), cwd=target, log=False)
    if source == old_source:
        message({'description': "origin already set"})
        return

    # origin changed
    msg = {
        'level': "warning",
        'description': "origin changed",
        'data': "\n".join([
            "old origin: `%s`" % old_source,
            "new origin: `%s`" % source])}
    execute(('git', 'remote', 'set-url', 'origin', source),
            cwd=target, msg=msg)


@action
def git_user(task, context={}):
    """Sets the username and useremail of a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # skip silently for upstream repos
    if upstream:
        return

    # skip silently, if userdata is not set
    if not git_name or not git_email:
        return

    # userdata already set
    old_username = execute(
        ('git', 'config', 'user.name'), cwd=target, log=False).strip('"')
    old_useremail = execute(
        ('git', 'config', 'user.email'), cwd=target, log=False).strip('"')
    if git_name == old_username and old_useremail == old_useremail:
        message({'description': "git user aready set"})
        return

    # userdata set
    execute(('git', 'config', 'user.name', '"{}"'.format(git_name)),
            cwd=target, log=False)
    execute(('git', 'config', 'user.email', '"{}"'.format(git_email)),
            cwd=target, log=False)
    message({'level': "info", 'description': "git user set",
             'data': "\n".join(["user.name: `%s`" % git_name,
                                "user.email: `%s`" % git_email])})


@action
def git_status(task, context={}):
    """Checks the status of the repository, cancels task if not ok."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # workdir checked
    cmd = ['git', 'status']
    if upstream:
        cmd.append('--untracked-files=no')

    # procelain
    if context['actions']['porcelain']:
        msg = {'level': lambda o: o and "warning" or "debug",
               'description':
                   lambda o: o and "workdir dirty -> update skipped" or "ok"}
        cmd.append('--porcelain')
        execute(cmd, cwd=target, stop_action_group=True, msg=msg)
        return

    # full
    clean = True
    colored = [colors['clear']]
    output = execute(cmd, cwd=target, stop_action_group=True, log=False)
    _color = ''
    for line in output.split("\n"):
        if line.startswith("  ("):
            _color = 'remove'
            if 'reset' in line:
                _color = 'add'
        if not line.startswith("\t"):
            colored.append(color(line, 'dim'))
            continue
        clean = False
        colored.append(color(line, _color))

    # clean workdir
    if clean:
        message({'level': "info", 'data': "\n".join(output)})
        return

    # dirty workdir
    message({'level': "warning", 'data': "\n".join(colored)})


@action
def git_fetch(task, context={}):
    """Fetches updates for a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']

    # skip silently for tags
    if version.startswith("tags/"):
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip silently for local only branches
    if not remote_exists:
        return

    # update branch, check for updates
    output = execute(
        ('git', 'fetch', 'origin', version), cwd=target, log=False)
    updates = False
    for line in output:
        if version + " -> " in line:
            if "FETCH_HEAD" in line:
                continue
            updates = True

    # updates available
    if updates:
        message({'level': "info", 'description': "updates available",
                 'data': output})
        return

    # uptodate
    message({'description': "uptodate"})


@action
def git_checkout(task, context={}):
    """Checksout a branch or tag in a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # get checked out version
    old_version = execute(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'), cwd=target, log=False)
    if old_version == "HEAD":
        old_version = execute(
            ('git', 'name-rev', '--name-only', 'HEAD'), cwd=target, log=False)
    if old_version.endswith("^0"):
        old_version = old_version[:-2]
    checked_out = old_version == version and True or False

    # find out, if branch or tag exists locally
    version_exists = False
    if version.startswith("tags/"):
        output = execute(
            ('git', 'tag', '-l', version[5:]), cwd=target, log=False)
        if output:
            version_exists = True
    else:
        output = execute(('git', 'branch', '-lvv'), cwd=target, log=False)
        for line in output.split("\n"):
            if line[2:].startswith(version + " "):
                version_exists = True

    # just checkout, if remote or local branch exists
    if version_exists:

        # version already checked out
        if checked_out:
            message({'description': "already on `%s`" % version})
            return

        # version switched
        msg = {'level': "info", 'description': "branch switched",
               'data': "\n".join(["old branch/tag: `%s`" % old_version,
                                  "new branch/tag: `%s`" % version])}
        execute(('git', 'checkout', '--quiet', version),
                cwd=target, msg=msg)
        return

    # upstream version does not exist
    if upstream or version.startswith("tags/"):
        error({'description': "no upstream version `%s` found" % version})

    # new branch created
    msg = {'level': 'info', 'description': "new branch created",
           'data': 'branch name: `%s`' % version}
    execute(('git', 'checkout', '-b', version), cwd=target, msg=msg)


@action
def git_track(task, context={}):
    """Ensures, that remote branches are followed."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # skip silently for upstream repos and tags
    if upstream or version.startswith("tags/"):
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip, if remote brach does not exist
    if not remote_exists:
        message({'description':
                 'upstream branch `%s` does not exist' % version})
        return

    # get currently tracked branch
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_tracked = tracked_branch == "origin/%s" % version

    # remote branch is already tracked
    if is_tracked:
        message({'description':
                 'upstream branch `%s` already tracked' % version})
        return

    # track remote branch
    # NOTE: conflicts, if the same branch was created and committed to on
    # different repositories. this edge case should be rare.
    msg = {'level': "info",
           'description':
               "switched upstream branch from `%s` to `%s`" % (
                   tracked_branch, "origin/%s" % version)}
    execute(('git', 'branch', '-u', 'origin/%s' % version, version),
            cwd=target, msg=msg)


@action
def git_pull(task, context={}):
    """Pulls updates in a repository branch."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']

    # skip pull silently for tags
    if task['version'].startswith("tags/"):
        return

    # skip pull for local only branches
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_local = not tracked_branch.startswith("origin/%s" % version)
    if is_local:
        message({'description': "no remote branch `%s` -> pull skipped"
                 % version})
        return

    # pull performed
    output = execute(('git', 'pull'), cwd=target, log=False)

    # updated
    if "changed" in output:
        message({'level': "info", 'description': "updated", 'data': output})
        return

    # uptodate
    message({'level': "debug", 'description': "uptodate"})


@action
def git_commit(task, context={}):
    """Commits all changed and untracked files."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)
    if not _commit_msg:
        error({'description': "no commit message"})

    # skip silently for upstream repos
    if upstream:
        return

    # skip repos with clean workdir
    output = execute(('git', 'status', '--porcelain'), cwd=target, log=False)
    if not output:
        message({'description': "nothing to commit"})
        return

    # add performed
    msg = {'level': "info", 'description': "changes added", 'data': output}
    execute(('git', 'add', '-A'), cwd=target, msg=msg)

    # commit performed
    msg = {'level': "info", 'description': "changes commited"}
    execute(('git', 'commit', '-m', _commit_msg),
            cwd=target, msg=msg, abort=False)


@action
def git_push(task, context={}):
    """Pushes all staged commits to remote origin."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)
    version = task['version']

    # skip silently for upstream repos
    if upstream:
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip local only branches
    if not remote_exists:
        message({'level': "warning", 'description': "no remote branch"})
        return

    # find out, if unpushed commits exist
    unpushed = execute(('git', 'log', '@{u}..'), cwd=target, log=False)

    # skip repos without commits
    if not unpushed:
        return

    # add performed
    msg = {'level': "info", 'description': "commits pushed", 'data': unpushed}
    execute(('git', 'push'), cwd=target, msg=msg)


@action
def script_restart(task, context={}):
    """Restarts the update script after updated of itself was checkedout."""
    # target = task['name']
    # updated = ['self']
    # if pull_result:
    #     if 'scripts/update |' in pull_result:
    #         updated.append('script')
    #     if 'services/build/Dockerfile |' in pull_result:
    #         updated.append('dockerfile')
    #     if '.example |' in pull_result:
    #         updated.append('examplefiles')
    pass


# --- tasks -------------------------------------------------------------------

def get_context():
    """Returns the current context."""
    if _contexts:
        return _contexts[-1]
    return


def set_context(override={}):
    """Sets the context for a command, adds it to the stack."""
    current_env = project[environment]
    current_cmd = override.get('command', _command)
    # default context
    context = {
        # command config
        'commands': current_env['commands'].get(current_cmd, {}),
        # current command
        'command': current_cmd,
        # command tasks
        'tasks': current_env['tasks'].get(current_cmd, []),
        # action config
        'actions': current_env['actions'],
        # current task
        'task': None,
        # current batch group
        'batch_group': {},
        # current action group
        'action_group': {},
        # current action
        'action': None,
    }
    # overrides
    context.update(override)
    # add context
    _contexts.append(context)
    return context


def process(context):
    """Main loop to process tasks."""
    # no tasks
    if not context.get('tasks'):
        error({'title': "No tasks"})
    # process tasks
    for task in context['tasks']:
        # batch tasks
        if task.get('batch'):
            batch_tasks = []
            for batch_task in task['batch']:
                batch_tasks.append({**task, **batch_task, **{'batch': False}})
            batch = set_context({
                'command': context['command'],
                'batch_group': task, 'tasks': batch_tasks})
            process(batch)
            continue
        # single tasks
        context['action_group'] = task
        context['task'] = task
        for action in task['actions']:
            if action not in _actions:
                error({'description': "action not found", 'data': task})
            context['action'] = action
            _tasks.append({**task, **{'action': action}})
            if action in _actions:
                getattr(sys.modules[__name__], action)(task, context)
    # do not remove the main context
    if len(_contexts) > 1:
        _contexts.pop()


# --- commands ----------------------------------------------------------------

def command(func):
    """Command decorator, handles context and wrap switch."""
    current_command = func.__name__
    # append command name to list of commands
    _commands.append(current_command)

    def wrapper(context={}, *args, **kwargs):
        # set new command context
        if not context:
            context = set_context({'command': _command})
        # apply filters
        try:
            func(context, *args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
        # print header
        header()
        # print title
        # title(_command.capitalize())
        # process tasks
        process(context)
        # print footer
        footer()
    return wrapper


@command
def update(context={}):
    """Updates itself and the repositories, creates folders, copies files."""
    pass


@command
def diff(context={}):
    """Prints the diffs of the example files."""
    # filter tasks
    tasks = []
    for task in context['tasks']:
        if 'file_diff' not in task['actions']:
            continue
        tasks.append(task)
    context['tasks'] = tasks


@command
def status(context={}):
    """Prints the status of the project repositories."""
    # filter tasks
    tasks = []
    for task in context['tasks']:
        if 'git_status' not in task['actions']:
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        tasks.append(task)
    context['tasks'] = tasks
    context['actions']['git_status']['porcelain'] = False


@command
def pull(context={}):
    """Pulls only the project repositories."""
    # filter tasks
    tasks = []
    for task in context['tasks']:
        if 'git_pull' not in task['actions']:
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        tasks.append(task)
    context['tasks'] = tasks


@command
def commit(context={}):
    """Commits changes and untracked files to the project repositories."""
    # filter tasks
    tasks = []
    for task in context['tasks']:
        if 'git_pull' not in task['actions']:
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        task['actions'] = ['git_commit']
        tasks.append(task)
    context['tasks'] = tasks


@command
def push(context={}):
    """Pushes commits of the project repositories."""
    # filter tasks
    tasks = []
    for task in context['tasks']:
        if 'git_pull' not in task['actions']:
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        task['actions'] = ['git_fetch', 'git_pull', 'git_push']
        tasks.append(task)
    context['tasks'] = tasks


# --- configuration -----------------------------------------------------------

# project
root = get_root_dir()
repo = get_repo_name(root)
env = get_dot_env(root)
project = get_project_yaml(root, env)
environments = project.keys()

# environment
environment = env['ENVIRONMENT']
branch = env['BRANCH']
git_name = env.get('GIT_USER_NAME')
git_email = env.get('GIT_USER_EMAIL')
git_protocol = env.get('GIT_SSH') and 'ssh' or 'https'

# messages
levels = {
    'output':  ['error', 'warning', 'info'],
    'summary': ['error', 'warning']
}
colors = {
    # level
    'error': "\033[91m",
    'error_level': 'error',
    'error_title': ['title', 'bold'],
    'error_action': '',
    'error_description': ['error', 'bold'],
    'error_data': 'dim',
    'warning': "\033[33m",
    'warning_level': 'warning',
    'warning_title': ['warning', 'bold'],
    'warning_action': '',
    'warning_description': 'warning',
    'warning_data': 'dim',
    'info': '',
    'info_level': 'info',
    'info_title': ['info', 'bold'],
    'info_action': 'info',
    'info_description': 'dim',
    'info_data': 'dim',
    'debug': "\033[2m",
    'debug_level': 'debug',
    'debug_title': ['debug', 'bold'],
    'debug_action': 'dim',
    'debug_description': 'debug',
    'debug_data': 'dim',
    # context
    'title': ['bold', "\033[33m"],
    'subtitle': "\033[35m",
    'output': "\033[94m",
    'success': "\033[32m",
    # diff
    'hunk': "\033[36m",
    'remove': "\033[31m",
    'add': "\033[32m",
    # function
    'clear': "\033[0m",
    'bold': "\033[1m",
    'dim': "\033[2m",
    'italic': "\033[3m",
    'underline': "\033[4m",
    'blink': "\033[5m",
}


# --- entrypoint --------------------------------------------------------------

if __name__ == "__main__":

    # set flags
    if "--reset" in sys.argv:
        _reset = True
    if "--verbose" in sys.argv:
        _verbose = True
    if "--debug" in sys.argv:
        _debug = True
        _verbose = True
    if "--ci" in sys.argv:
        _ci = True
        _colored = False
        _reset = True
        _verbose = True
        _debug = True
    for param in sys.argv:
        if param.startswith('--updated='):
            updated = param[11:].split(',')
            if 'self' in updated:
                _self_updated = True
            if 'script' in updated:
                _script_updated = True
            if 'dockerfile' in updated:
                _dockerfile_updated = True
            if 'examplefiles' in updated:
                _examplefiles_updated = True

    # process flags
    if _verbose:
        levels['output'].append('debug')
    if _debug:
        levels['output'].append('debug')

    # choose command
    _command = 'update'
    for i, param in enumerate(sys.argv):
        if param == "--help":
            _command = 'help'
            break
        if param == "--diff":
            _command = 'diff'
            break
        if param == "--status":
            _command = 'status'
            break
        if param == "--pull":
            _command = 'pull'
            break
        if param == "--push":
            _command = 'push'
            break
        if param == "--commit":
            _command = 'commit'
            if len(sys.argv) < i + 2:
                sys.exit("No commit message")
            _commit_msg = sys.argv[i + 1]

    # print help
    if _command == 'help':
        print(__doc__.strip())
        sys.exit(2)

    # sanity check
    if _command not in _commands:
        sys.exit("command `%s` not found" % _command)

    # set workdir
    os.chdir(root)

    # execute command
    getattr(sys.modules[__name__], _command)()
