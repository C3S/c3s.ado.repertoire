#!/usr/bin/env python3
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/collecting_society_docker
"""
Usage: ./scripts/update [--reset] [--diff] [--help]

  This script updates the project:
    - Creation of files and folders
    - Copy of FILE.example files to FILE
    - Checkout/Pull of the source repositories (including this one)
    - Checkout/Pull of the reference repositories

Options:
  --reset: overrides the configuration files with .example
  --diff: just outputs the diff of .example files, performs no other updates
"""

import os
import sys
import shutil
import subprocess
from pathlib import Path
import difflib
import re


header = """
==============================================================================
  This is the {} update script.
  It will create folders and copy files, if not present (use --reset to force)
  and clone or pull the neccessary repositories.

  Using {} on branch {}
  Installing/updating in {}
  Reading info from config...
  Checking repositories...
------------------------------------------------------------------------------
"""

footer = """\n\nDone.\n
=====================================================================
  Now you may go ahead and use
    * 'docker-compose build' to build the project
    * 'docker-compose up' to start the project
=====================================================================
"""


def get_root_dir():
    """Returns the root dir of the repository."""
    try:
        return subprocess.check_output(
            ['git', 'rev-parse', '--show-toplevel'], stderr=subprocess.STDOUT
        ).rstrip().decode('utf-8')
    except subprocess.CalledProcessError:
        directory = os.path.dirname(os.path.realpath(__file__))
        return os.path.realpath(os.path.join(directory, ".."))


def get_shared_env(path=False):
    """Reads the shared environment file and parses it into a dictionary."""

    # get path
    if not path:
        path = os.path.join(get_root_dir(), '.env')
    if not os.path.isfile(path):
        path = os.path.join(get_root_dir(), '.env.example')
    assert os.path.isfile(path)

    # parse file
    result = {}
    envre = re.compile(r'''^([^\s=]+)=(?:[\s"']*)(.+?)(?:[\s"']*)$''')
    with open(path) as ins:
        for line in ins:
            match = envre.match(line)
            if match is not None:
                result[match.group(1)] = match.group(2)
    return result


# environment
env = get_shared_env()
project = env['PROJECT'] + "_docker"
git_branch = subprocess.check_output(
    ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
    stderr=subprocess.STDOUT).rstrip().decode('utf-8')
branch = env['ENVIRONMENT']
if env['ENVIRONMENT'] == "testing":
    branch = "production"

# paths
dirs = {}
dirs['root'] = get_root_dir()
dirs['code'] = dirs['root'] + "/code"
dirs['scripts'] = dirs['root'] + "/scripts"
dirs['services'] = dirs['root'] + "/services"
dirs['volumes'] = dirs['root'] + "/volumes"
dirs['shared'] = dirs['volumes'] + "/shared"
dirs['ref'] = dirs['shared'] + "/ref"
dirs['src'] = dirs['shared'] + "/src"
dirs['tests'] = dirs['shared'] + "/tests"
dirs['tmp'] = dirs['shared'] + "/tmp"
dirs['logs'] = dirs['tmp'] + "/logs"
update_script = os.path.abspath(__file__)

# folders to create
create_folders = [
    dirs['code'],
    dirs['tmp'],
    dirs['tests'],
    dirs['logs'],
]
if env['ENVIRONMENT'] in ["development", "staging", "testing"]:
    create_folders += [
        dirs['volumes'] + '/postgresql-data',
        dirs['volumes'] + '/trytond-files',
        dirs['volumes'] + '/nginx-certs',
        dirs['volumes'] + '/nginx-dhparam',
        dirs['volumes'] + '/nginx-htpasswd',
        dirs['volumes'] + '/echoprint-data',
    ]

# files to copy
copy_files = [
    {
        'source': dirs['root'] + '/.env.example',
        'target': dirs['root'] + '/.env'
    },
    {
        'source': dirs['root'] + '/.devcontainer.json.example',
        'target': dirs['root'] + '/.devcontainer.json'
    },
    {
        'source': dirs['shared'] + '/config/trytond/passfile.example',
        'target': dirs['shared'] + '/config/trytond/passfile',
    },
    {
        'source': dirs['shared'] + '/config/trytond/staging.conf.example',
        'target': dirs['shared'] + '/config/trytond/staging.conf',
    },
    {
        'source': dirs['shared'] + '/config/trytond/production.conf.example',
        'target': dirs['shared'] + '/config/trytond/production.conf',
    },
    {
        'source': dirs['services'] + '/webgui.env.example',
        'target': dirs['services'] + '/webgui.env'
    },
    {
        'source': dirs['services'] + '/webapi.env.example',
        'target': dirs['services'] + '/webapi.env'
    },
    {
        'source': dirs['services'] + '/worker.env.example',
        'target': dirs['services'] + '/worker.env'
    },
    {
        'source':
            dirs['src'] + '/collecting_society_worker/config.ini.example',
        'target': dirs['src'] + '/collecting_society_worker/config.ini'
    },
]

# source repositories to clone
clone_sources = [
    # upstream: tryton
    {
        'url': 'https://github.com/tryton/trytond.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'trytond'
    },
    {
        'url': 'https://github.com/tryton/country.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'country'
    },
    {
        'url': 'https://github.com/tryton/currency.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'currency'
    },
    {
        'url': 'https://github.com/tryton/party.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'party'
    },
    {
        'url': 'https://github.com/tryton/company.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'company'
    },
    {
        'url': 'https://github.com/tryton/product.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'product'
    },
    {
        'url': 'https://github.com/tryton/account.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'account'
    },
    {
        'url': 'https://github.com/tryton/account_product.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'account_product'
    },
    {
        'url': 'https://github.com/tryton/account_invoice.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'account_invoice'
    },
    {
        'url': 'https://github.com/tryton/account_invoice_line_standalone.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'account_invoice_line_standalone'
    },
    {
        'url': 'https://github.com/tryton/bank.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'bank'
    },
    {
        'url': 'https://github.com/tryton/account_de_skr03.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'account_de_skr03'
    },
    {
        'url': 'https://github.com/virtualthings/web_user.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'web_user'
    },
    # custom: tryton
    {
        'url': 'https://github.com/C3S/archiving.git',
        'ssh': 'git@github.com:C3S/archiving.git',
        'option': '--branch=' + branch,
        'path': 'archiving',
        'symlink': False
    },
    {
        'url': 'https://github.com/C3S/portal.git',
        'ssh': 'git@github.com:C3S/portal.git',
        'option': '--branch=' + branch,
        'path': 'portal',
        'symlink': False
    },
    {
        'url': 'https://github.com/C3S/collecting_society.git',
        'ssh': 'git@github.com:C3S/collecting_society.git',
        'option': '--branch=' + branch,
        'path': 'collecting_society',
        'symlink': True
    },
    # custom: pyramid
    {
        'url': 'https://github.com/C3S/portal_web.git',
        'ssh': 'git@github.com:C3S/portal_web.git',
        'option': '--branch=' + branch,
        'path': 'portal_web',
        'symlink': True
    },
    {
        'url': 'https://github.com/C3S/collecting_society_web.git',
        'ssh': 'git@github.com:C3S/collecting_society_web.git',
        'option': '--branch=' + branch,
        'path': 'collecting_society_web',
        'symlink': True
    },
    # upstream: worker
    {
        'url': 'https://github.com/spotify/echoprint-codegen.git',
        'option': '--branch=master',
        'path': 'echoprint-codegen'
    },
    # custom: worker
    {
        'url': 'https://github.com/C3S/echoprint-server.git',
        'ssh': 'git@github.com:C3S/echoprint-server.git',
        'option': '--branch=master',
        'path': 'echoprint-server',
        'symlink': True
    },
    {
        'url': 'https://github.com/C3S/collecting_society_worker.git',
        'ssh': 'git@github.com:C3S/collecting_society_worker.git',
        'option': '--branch=' + branch,
        'path': 'collecting_society_worker',
        'symlink': True
    },
]

# reference repositories to clone development stage only
clone_references = [
    {
        'url': 'https://github.com/pallets/click.git',
        'option': '--tag=4.0',
        'path': 'click'
    },
    {
        'url': 'https://github.com/requests/requests.git',
        'option': '--tag=v2.18.4',
        'path': 'requests'
    },
    {
        'url': 'https://github.com/psycopg/psycopg2.git',
        'option': '--tag=2_5_4',
        'path': 'psycopg2'
    },
    {
        'url': 'https://github.com/tryton/proteus.git',
        'option': '--branch=' + env['TRYTON_VERSION'],
        'path': 'proteus'
    },
    {
        'url': 'https://github.com/Pylons/webob.git',
        'option': '--tag=v1.8.2',
        'path': 'webob'
    },
    {
        'url': 'https://github.com/Pylons/pyramid.git',
        'option': '--tag=1.9.2',
        'path': 'pyramid'
    },
    {
        'url': 'https://github.com/Pylons/pyramid_beaker.git',
        'option': '--tag=0.8',
        'path': 'pyramid_beaker'
    },
    {
        'url': 'https://github.com/Pylons/pyramid_chameleon.git',
        'option': '--tag=0.3',
        'path': 'pyramid_chameleon'
    },
    {
        'url': 'https://github.com/Pylons/pyramid_mailer.git',
        'option': '--tag=0.15.1',
        'path': 'pyramid_mailer'
    },
    {
        'url': 'https://github.com/Pylons/colander.git',
        'option': '--tag=1.4',
        'path': 'colander'
    },
    {
        'url': 'https://github.com/Cornices/cornice.git',
        'option': '--tag=3.4.0',
        'path': 'cornice'
    },
    {
        'url': 'https://github.com/Cornices/cornice.ext.swagger.git',
        'option': '--tag=0.7.0',
        'path': 'cornice_swagger'
    },
    {
        'url': 'https://github.com/Pylons/deform.git',
        'option': '--tag=2.0.5',
        'path': 'deform'
    },
    {
        'url': 'https://github.com/jiaaro/pydub.git',
        'option': '--tag=v0.22.0',
        'path': 'pydub'
    },
    {
        'url': 'https://github.com/supermihi/pytaglib.git',
        'option': '--tag=v1.4.3',
        'path': 'pytaglib'
    },
    {
        'url': 'https://github.com/echonest/pyechonest.git',
        'option': '--tag=9.0.0',
        'path': 'pyechonest'
    },
]


def update_self():
    """Updates the update script."""

    print('checking for updates of this script ... ', end='')

    # check workingdir
    workingdir_dirty = subprocess.check_output(
        ('git', 'status', '--untracked-files=no', '--porcelain'),
        cwd=dirs['root'], stderr=subprocess.STDOUT).rstrip().decode('utf-8')
    if workingdir_dirty:
        print("\nWARNING: Working directory not clean. Udpate omitted!" +
              "\n\033[91m{}\033[0m".format(workingdir_dirty))
        return

    # check for updates
    try:
        print("update_self: trying git fetch...")
        subprocess.check_output(
            ('git', 'fetch'),
            cwd=dirs['root'], stderr=subprocess.STDOUT
            ).rstrip().decode('utf-8')
        print("update_self: trying git diff --quiet remotes/origin/%s .."
              % git_branch)
        subprocess.check_output(
            ('git', 'diff', '--quiet', 'remotes/origin/%s' % git_branch),
            cwd=dirs['root'], stderr=subprocess.STDOUT
            ).rstrip().decode('utf-8')
        print('up-to-date.')
        return
    except subprocess.CalledProcessError:
        print('differences found, trying to update.')

    # update
    try:
        print('git pull "' + project + '": ', end='')
        pull_result = subprocess.check_output(
            ('git', 'pull'),
            cwd=dirs['root'], stderr=subprocess.STDOUT
            ).rstrip().decode('utf-8')
        if pull_result:
            print(pull_result)
        subprocess.call(update_script)
        exit()

    except subprocess.CalledProcessError as e2:
        print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
            e2.output.rstrip().decode('utf-8')))
        sys.exit("Exiting. Please check for errors above!")

    # configure user
    username = env.get('GIT_USER_NAME')
    useremail = env.get('GIT_USER_EMAIL')
    if username and useremail:
        print('configure user {} <{}>: '.format(username, useremail), end='')
        try:
            subprocess.check_output(
                ('git', 'config', 'user.name', '"{}"'.format(username)),
                cwd=dirs['root'], stderr=subprocess.STDOUT)
            subprocess.check_output(
                ('git', 'config', 'user.email', '"{}"'.format(useremail)),
                cwd=dirs['root'], stderr=subprocess.STDOUT)
            print('ok.')
        except subprocess.CalledProcessError as e2:
            print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
                e2.output.rstrip().decode('utf-8')))
            sys.exit("Exiting. Please check for errors above!")


def update_repository(repo, branch, path, username=False, useremail=False,
                      symlink=False):
    """Updates a BRANCH of a repository REPO in PATH."""

    # sanity checks
    if not repo or not branch or not path:
        return
    repo_relpath = os.path.relpath(path, dirs['root'])
    repo_name = os.path.basename(os.path.normpath(path))

    # create path
    if not os.path.exists(path):
        print('Missing directory, creating {}'.format(repo_relpath))
        os.makedirs(path)

    # get git option
    if branch.startswith('--branch='):
        target_type = 'branch'
        target_value = branch.lstrip('--branch=')
        target_param = target_value
    if branch.startswith('--tag='):
        target_type = 'tag'
        target_value = branch.lstrip('--tag=')
        target_param = target_value

    print('\nREPO: ' + repo_name)
    print('--------------------------------------------------------------')

    # clone repository
    try:
        print('Will use git to clone "{}" {} "{}" into "{}": '.format(
            repo, target_type, target_value, repo_relpath))
        clone_result = subprocess.check_output(
            ('git', 'clone', '--branch', target_param, repo, path),
            stderr=subprocess.STDOUT).rstrip().decode('utf-8')
        print('git clone "{}": '.format(repo_name))
        if clone_result:
            print('::'.join(
                x for x in clone_result.strip().split('\n')))

    # pull repository
    except subprocess.CalledProcessError:

        # ensure, right remote url is set
        subprocess.check_output(
            ('git', 'remote', 'set-url', 'origin', repo),
            cwd=path, stderr=subprocess.STDOUT)

        # check, if the working directory is clean
        workingdir_dirty = subprocess.check_output(
            ('git', 'status', '--untracked-files=no', '--porcelain'),
            cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
        if workingdir_dirty:
            print("WARNING: Working directory not clean. Udpate omitted!" +
                  "\n\033[91m{}\033[0m".format(workingdir_dirty))
            return
        print("Directory exists; using pull instead of clone:")

        # checkout tag
        if target_type == 'tag':
            print('git checkout "{}": '.format(repo_name), end='')
            checkout_result = subprocess.check_output(
                ('git', 'checkout', 'tags/' + target_param),
                cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
            if checkout_result:
                print('::'.join(
                    x for x in checkout_result.strip().split('\n')))
            return

        # checkout branch
        subprocess.check_output(
            ('git', 'checkout', target_param),
            cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')

        # pull
        try:
            pull_result = subprocess.check_output(
                ('git', 'pull'),
                cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
            print('git pull "{}": '.format(repo_name), end='')
            if pull_result:
                print('::'.join(
                    x for x in pull_result.strip().split('\n')))
        except subprocess.CalledProcessError as e2:
            print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
                e2.output.rstrip().decode('utf-8')))
            sys.exit("Exiting. Please check for errors above!")

    # configure user
    if username and useremail:
        print('configure user {} <{}>: '.format(username, useremail), end='')
        try:
            subprocess.check_output(
                ('git', 'config', 'user.name', '"{}"'.format(username)),
                cwd=path, stderr=subprocess.STDOUT)
            subprocess.check_output(
                ('git', 'config', 'user.email', '"{}"'.format(useremail)),
                cwd=path, stderr=subprocess.STDOUT)
            print('ok.')
        except subprocess.CalledProcessError as e2:
            print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
                e2.output.rstrip().decode('utf-8')))
            sys.exit("Exiting. Please check for errors above!")

    # symlink
    if symlink:
        symlink_path = os.path.join(dirs['code'], repo_name)
        if os.path.islink(symlink_path):
            print("symlink already present.")
        else:
            os.symlink(path,  symlink_path)
            print("symlink created.")


def create_folder(path):
    """Creates a folder in PATH."""
    if not os.path.isdir(path):
        os.makedirs(path)
        print('\t[create] %s' % path)
    else:
        print('\t[exists] %s' % path)


def copy_file(source_file, target_file, reset=False):
    """Copies a file from root_dir/SOURCE_FILE to root_dir/TARGET_FILE."""
    target = os.path.join(dirs['root'], target_file)
    if not os.path.isfile(target) or reset:
        source = os.path.join(dirs['root'], source_file)
        shutil.copyfile(source, target)
        if reset:
            print('\t[forced] %s' % target_file)
        else:
            print('\t[copied] %s' % target_file)
    else:
        print('\t[exists] %s' % target_file)


def diff_example_files(offset=8):
    """Diffs the example files and returns the output."""
    for path in Path(dirs['root']).rglob('*.example'):
        example_path = str(path)
        copied_path = str(path)[:-8]
        if not os.path.exists(copied_path):
            continue
        start = len(dirs['root']) + 1
        example_name = example_path[start:]
        copied_name = copied_path[start:]
        example_file = open(example_path).readlines()
        copied_file = open(copied_path).readlines()
        diff = difflib.unified_diff(
            example_file, copied_file,
            fromfile=example_name, tofile=copied_name)
        try:
            line = next(diff)
        except StopIteration:
            continue
        if line:
            print(" " * offset + "-" * 79)
            print(" " * offset + copied_name)
            print(" " * offset + "-" * 79)
            print(" " * offset + line, end="")
            for line in diff:
                print(" " * offset + line, end="")
            print()


def update():
    """Updates itself and the repositories, creates folders, copies files."""

    if "--diff" in sys.argv:
        diff_example_files(0)
        sys.exit()

    # header
    print(header.format(project, project, git_branch, dirs['root']))

    # update update script itself
    update_self()

    # create folders
    print("\nCreating symlink to docker-compose.override.yml ... ", end='')
    override = 'development'
    if env['ENVIRONMENT'] == 'production':
        override = 'production'
    symlink_source = os.path.join(
        dirs['root'], 'docker-compose.' + override + '.yml')
    symlink_target = os.path.join(
        dirs['root'], 'docker-compose.override.yml')
    if os.path.islink(symlink_target):
        print("already present.")
    else:
        os.symlink(symlink_source, symlink_target)
        print("created.")

    # create folders
    print("\nCreating folders ...\n")
    for folder in create_folders:
        create_folder(folder)

    # update source repositories
    for repo in clone_sources:
        url = repo['url']
        if int(env.get('GIT_SSH')) and 'ssh' in repo:
            url = repo['ssh']
        option = repo['option']
        path = os.path.join(dirs['src'], repo['path'])
        username = env.get('GIT_USER_NAME')
        useremail = env.get('GIT_USER_EMAIL')
        symlink = repo.get('symlink')
        update_repository(url, option, path, username, useremail, symlink)

    # update reference repositories
    if env['ENVIRONMENT'] == "development":
        for repo in clone_references:
            url = repo['url']
            if int(env['GIT_SSH']) and 'ssh' in repo:
                url = repo['ssh']
            option = repo['option']
            path = os.path.join(dirs['ref'], repo['path'])
            username = env.get('GIT_USER_NAME')
            useremail = env.get('GIT_USER_EMAIL')
            symlink = repo.get('symlink')
            update_repository(url, option, path, username, useremail, symlink)

    # copy files
    print("\nCopying files ...\n")
    for file in copy_files:
        reset = len(sys.argv) > 1 and sys.argv[1] == "--reset"
        copy_file(file['source'], file['target'], reset)

    # diff example file
    if branch == 'development':
        print("\nDiffing example files ...\n")
        diff_example_files()

    # footer
    print(footer)


if __name__ == "__main__":
    os.chdir(dirs['root'])
    if "--help" in sys.argv:
        print(__doc__.strip())
        sys.exit(2)
    update()
