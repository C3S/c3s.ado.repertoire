#!/usr/bin/env python3
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/collecting_society_docker
"""Builds and updates development and production environment"""

import os
import sys
import shutil
import subprocess
import config

project = config.env['PROJECT'] + "_docker"
update_script = os.path.abspath(__file__)
base_path = config.dirs['root']
os.chdir(base_path)
git_branch = subprocess.check_output(
    ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
    stderr=subprocess.STDOUT).rstrip().decode('utf-8')

header = """
==============================================================================
  This is the {} update script.
  It will create folders and copy files, if not present (use --reset to force)
  and clone or pull the neccessary repositories.

  Using {} on branch {}
  Installing/updating in {}
  Reading info from config...
  Checking repositories...
------------------------------------------------------------------------------
"""

footer = """\n\nDone.\n
=====================================================================
  Now you may go ahead and use
    * 'docker-compose build' to build or
    * 'docker-compose up' to start the system.
=====================================================================
"""


def update_self():
    """Updates the update script."""

    # check for updates
    print('checking for updates of this script ... ', end='')
    try:
        subprocess.check_output(
            ('git', 'diff', '--quiet', 'remotes/origin/HEAD'),
            cwd=base_path, stderr=subprocess.STDOUT
            ).rstrip().decode('utf-8')
        print('up-to-date.')
        return
    except subprocess.CalledProcessError:
        print('differences found, trying to update.')

    # update
    try:
        print('git pull "' + project + '": ', end='')
        pull_result = subprocess.check_output(
            ('git', 'pull'),
            cwd=base_path, stderr=subprocess.STDOUT
            ).rstrip().decode('utf-8')
        if pull_result:
            print(pull_result)
        subprocess.check_output(
            update_script, stderr=subprocess.STDOUT)
        exit()

    except subprocess.CalledProcessError as e2:
        print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
            e2.output.rstrip().decode('utf-8')))
        sys.exit("Exiting. Please check for errors above!")


def update_repository(repo, branch, path):
    """Updates a BRANCH of a repository REPO in PATH."""

    # sanity checks
    if not repo or not branch or not path:
        return
    repo_relpath = os.path.relpath(path, base_path)
    repo_name = os.path.basename(os.path.normpath(path))

    # create path
    if not os.path.exists(path):
        print('Missing directory, creating {}'.format(repo_relpath))
        os.makedirs(path)

    # get git option
    if branch.startswith('--branch='):
        target_type = 'branch'
        target_value = branch.lstrip('--branch=')
        target_param = target_value
    if branch.startswith('--tag='):
        target_type = 'tag'
        target_value = branch.lstrip('--tag=')
        target_param = target_value

    print('\nREPO: ' + repo_name)
    print('--------------------------------------------------------------')

    # clone repository
    try:
        print('Will use git to clone "{}" {} "{}" into "{}": '.format(
            repo, target_type, target_value, repo_relpath))
        clone_result = subprocess.check_output(
            ('git', 'clone', '--branch', target_param, repo, path),
            stderr=subprocess.STDOUT).rstrip().decode('utf-8')
        print('git clone "{}": '.format(repo_name))
        if clone_result:
            print('::'.join(
                x for x in clone_result.strip().split('\n')))

    # pull repository
    except subprocess.CalledProcessError:

        # check, if the working directory is clean
        workingdir_dirty = subprocess.check_output(
            ('git', 'status', '--untracked-files=no', '--porcelain'),
            cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
        if workingdir_dirty:
            print("WARNING: Working directory not clean. Udpate omitted!" +
                  "\n\033[91m{}\033[0m".format(workingdir_dirty))
            return
        print("Directory exists; using pull instead of clone:")

        # checkout tag
        if target_type == 'tag':
            print('git checkout "{}": '.format(repo_name), end='')
            checkout_result = subprocess.check_output(
                ('git', 'checkout', 'tags/' + target_param),
                cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
            if checkout_result:
                print('::'.join(
                    x for x in checkout_result.strip().split('\n')))
            return

        # checkout branch
        subprocess.check_output(
            ('git', 'checkout', target_param),
            cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')

        # pull
        try:
            pull_result = subprocess.check_output(
                ('git', 'pull'),
                cwd=path, stderr=subprocess.STDOUT).rstrip().decode('utf-8')
            print('git pull "{}": '.format(repo_name), end='')
            if pull_result:
                print('::'.join(
                    x for x in pull_result.strip().split('\n')))
        except subprocess.CalledProcessError as e2:
            print("There was a problem: \n\n\033[91m{}\033[0m\n".format(
                e2.output.rstrip().decode('utf-8')))
            sys.exit("Exiting. Please check for errors above!")


def create_folder(path):
    """Creates a folder in PATH."""
    if not os.path.isdir(path):
        os.makedirs(path)
        print('\t[create] %s' % path)
    else:
        print('\t[exists] %s' % path)


def copy_file(source_file, target_file, reset=False):
    """Copies a file from base_path/SOURCE_FILE to base_path/TARGET_FILE."""
    target = os.path.join(base_path, target_file)
    if not os.path.isfile(target) or reset:
        source = os.path.join(base_path, source_file)
        shutil.copyfile(source, target)
        if reset:
            print('\t[forced] %s' % target_file)
        else:
            print('\t[copied] %s' % target_file)
    else:
        print('\t[exists] %s' % target_file)


def update():
    """Updates itself and the repositories, creates folders, copies files."""

    # header
    print(header.format(project, project, git_branch, base_path))

    # update update script itself
    update_self()

    # update source repositories
    for repo, branch, path in config.clone_sources:
        repo_path = os.path.join(config.dirs['src'], path)
        update_repository(repo, branch, repo_path)

    # update reference repositories
    if config.env['ENVIRONMENT'] == "development":
        for repo, branch, path in config.clone_references:
            repo_path = os.path.join(config.dirs['ref'], path)
            update_repository(repo, branch, repo_path)

    # create folders
    print("\nCreating folders ...\n")
    for folder in config.create_folders:
        create_folder(folder)

    # copy files
    print("\nCopying files ...\n")
    for source_filename, target_filename in config.copy_files:
        reset = len(sys.argv) > 1 and sys.argv[1] == "--reset"
        copy_file(source_filename, target_filename, reset)

    # footer
    print(footer)


if __name__ == "__main__":
    update()
