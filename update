#!/usr/bin/env python
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/c3s.ado.repertoire
'''Builds and updates dev and production environment'''
from __future__ import print_function

import os
import shutil
import subprocess
import config
import sys

base_path = os.path.dirname(os.path.abspath(__file__))
git_branch = subprocess.check_output(
    ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
    stderr=subprocess.STDOUT)
print("""=====================================================================
  This is the c3s.ado.repertoire update script.
  It will get or update some relevant repositories.

  Using c3s.ado.repertoire on branch {}
  Installing/updating in {}
  Reading info from config...
  Checking repositories...
------------------------------------------------------------
""".format(
    git_branch,
    base_path
))

# update ado itself (of course won't recognize updates to the update script)
try:
    pull_result = subprocess.check_output(
        ('git', 'pull'), cwd=base_path,
        stderr=subprocess.STDOUT)
    print(
        'git pull "{}": '.format(os.path.basename(base_path)),
        end='')
    if pull_result:
        print(pull_result)
except subprocess.CalledProcessError as e2:
    print("There was a problem: \n\n{}".format(e2.output))
    sys.exit("Exiting. Please check for errors above!")

# update all the modules
for repo, branch, path in config.repositories:
    target_path = os.path.join(base_path, path)
    if not os.path.exists(target_path):
        print('Missing directory, creating {}'.format(path))
        os.makedirs(target_path)
    if repo:
        print('\nREPO: ' + os.path.basename(os.path.normpath(target_path)))
        print('--------------------------------------------------------------')
        if branch.startswith('--branch='):
            target_type = 'branch'
            target_value = branch.lstrip('--branch=')
            target_param = target_value
        if branch.startswith('--tag='):
            target_type = 'tag'
            target_value = branch.lstrip('--tag=')
            target_param = target_value
        try:
            print('Will use git to clone "{}" {} "{}" into "{}": '.format(
                repo, target_type, target_value, path))
            clone_result = subprocess.check_output(
                ('git', 'clone', '--branch', target_param, repo, target_path),
                stderr=subprocess.STDOUT)
            print(
                'git clone "{}": '.format(os.path.basename(target_path)))
            if clone_result:
                    print('::'.join(
                        x for x in clone_result.strip().split('\n')))
        except subprocess.CalledProcessError as e:
            # check, if the working directory is clean
            workingdir_dirty = subprocess.check_output(
                ('git', 'status', '--untracked-files=no', '--porcelain'),
                cwd=target_path,
                stderr=subprocess.STDOUT)
            if workingdir_dirty:
                print("\033[91m" +
                      "WARNING: Working directory not clean. Udpate omitted!" +
                      "\n{}\033[0m".format(workingdir_dirty))
                continue
            print("Directory exists; using pull instead of clone:")
            # first: make sure the repo is on the correct branch
            if target_type == 'tag':
                print(
                    'git checkout "{}": '.format(
                        os.path.basename(target_path)),
                    end='')
                checkout_result = subprocess.check_output(
                    ('git', 'checkout', 'tags/' + target_param),
                    cwd=target_path,
                    stderr=subprocess.STDOUT)
                if checkout_result:
                    print('::'.join(
                        x for x in checkout_result.strip().split('\n')))
                continue
            checkout_branch = subprocess.check_output(
                ('git', 'checkout', target_param),
                cwd=target_path,
                stderr=subprocess.STDOUT)
            try:
                pull_result = subprocess.check_output(
                    ('git', 'pull'), cwd=target_path,
                    stderr=subprocess.STDOUT)
                print(
                    'git pull "{}": '.format(os.path.basename(target_path)),
                    end='')
                if pull_result:
                    print(
                        '::'.join(x for x in pull_result.strip().split('\n')))
            except subprocess.CalledProcessError as e2:
                print("There was a problem: \n\n{}".format(e2.output))
                sys.exit("Exiting. Please check for errors above!")

for source_filename, target_filename in config.configfiles:
    target = os.path.join(base_path, target_filename)
    clean = len(sys.argv) > 1 and sys.argv[1] == "--reset"
    if not os.path.isfile(target) or clean:
        source = os.path.join(base_path, source_filename)
        print('copy file %s to %s' % (source_filename, target_filename))
        shutil.copyfile(source, target)

print("""

Done.

=====================================================================
  Now you may go ahead and use
    * 'docker-compose run tryton ado-do update c3s'
    * 'docker-compose run tryton ado-do db-delete c3s'
    * 'docker-compose build' to build or
    * 'docker-compose up' to start the system.
=====================================================================""")
